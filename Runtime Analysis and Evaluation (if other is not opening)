
Vector Data Structure Runtime Analysis
Operation	Cost per Execution	Number of Executions	Total Cost
Initialize lists	1	1	1
Read next line from file	1	N	n
Split line into tokens	1	N	n
Check if tokens < 2	1	N	n
Store course numbers	1	n	n
Store parsed data	1	n	n
Validate prerequisites 	n	n	n^2
Create course object	1	n	n
Add course to vector	1	n	n

Hash Table Runtime Analysis
Operation	Cost per Execution	Number of Executions	Total Cost
Initialize lists 	1	1	1
Read next line from file	1	n	n
Split line into tokens	1	n	n
Check if tokens < 2	1	n	n
Store course numbers	1	n	n
Store parsed data	1	n	n
Validate prerequisites 	n	n	n^2
Create course object	1	n	n
Insert into hash table 	n	n	n^2

Binary Search Tree Runtime Analysis
Operation	Cost per Execution	Number of Executions	Total Cost
Initialize lists 	1	1	1
Read next line from file	1	n	n
Split line into tokens	1	n	n
Check if tokens < 2	1	n	n
Store course numbers	1	n	n
Store parsed data	1	n	n
Validate prerequisites	n	n	n^2
Create course object	1	n	n
Insert into BST	n	n	n^2
Total Worst-Case Runtime: O(n^2)
Memory Usage: O(n)
Advantages and Disadvantages
Vector
The vector data structure is easy to understand and implement for effective sequential access to data, which makes the process of going through all the courses efficient. Also, adding course objects to a vector is straightforward and does not require deep thinking. However, vectors become inefficient for this type of stored data because searching for a specific course requires a linear search with a time complexity of O(n), especially when the number of courses increases. Additionally, vectors don’t keep sorted data, so every time the data needs to be printed in alphanumeric order the program must sort the courses which in turn demands more processing time, thus affecting performance.
Hash Table
The hash table data structure allows for quick access to data which facilitates the search for courses as it is performed in constant time O(1). This is excellent when retrieving course prerequisites and specific course information, which is one of the advisor’s main requirements. However, just like vectors, hash tables don’t store sorted data which directly impacts processing time and performance. Additionally, in the worst case, collisions can happen when several keys map to the same index which reduces performance to O(n), thus affecting the efficiency of search and insertion operations of the program.
Binary Search Tree (BST)
The binary search tree (BST) data structure keeps data organized meaning that it can preserve the sorted order of data, which helps greatly with the requirement of printing courses in alphanumeric order. As the BST uses in-order traversal, it can display all courses in sorted order without requiring an additional sorting step that makes an impact on performance, which makes generating the course list efficiently. Additionally, searching for a course can be performed in O(log n) on average. However, if the tree becomes unbalanced, performance can be reduced to O(n). 
Recommendation
Based on my analysis of the three data structures, the best fit for this program would be the binary search tree (BST). Despite all of the data structures having a worst-case runtime scenario, specifically when loading and validating data, the BST has a very strong point which is that it maintains data in sorted format. This allows the program to print courses in alphanumeric order without extra sorting steps thanks to the use of in-order traversal. Despite the hash table and vector data structure having some advantages, they don’t maintain sorted data which has a direct impact on performance. This makes the BST the most appropriate structure for the advising system as it offers an optimal balance between effective searching and storing sorted data.
